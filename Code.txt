import pandas as pd
import numpy as np
import pandas_ta as ta

def apply_indicator(df, result, prefix=None):
    """
    df       : 원본 DataFrame
    result   : pandas Series 또는 DataFrame (지표 결과)
    prefix   : Series 결과일 때 사용할 컬럼명
    """
    if isinstance(result, pd.Series):
        df[prefix or result.name] = result
    else:
        df = df.join(result)
    return df

# 1) 원본 데이터 로드 및 Date 파싱
dataName = 'data.base.csv'
df = pd.read_csv(dataName, parse_dates=['Date'], encoding='utf-8-sig')

# 2) 지표 계산을 위한 설정
lengths = range(2, 10)
indicator_cfg = [
    (ta.aroon,    True,  None,               lambda d,l: {'high': d.High, 'low': d.Low,   'length': l}),
    (ta.dm,       True,  None,               lambda d,l: {'high': d.High, 'low': d.Low,   'length': l}),
    (ta.eri,      True,  None,               lambda d,l: {'high': d.High, 'low': d.Low,   'close': d.Close, 'length': l}),
    (ta.efi,      True,  'EFI_{length}',     lambda d,l: {'close': d.Close, 'volume': d.Volume, 'length': l}),
    (ta.ema,      True,  'EMA_{length}',     lambda d,l: {'close': d.Close, 'length': l}),
    (ta.ema,      True,  'VolEMA_{length}',  lambda d,l: {'close': d.Volume, 'length': l}),
    (ta.roc,      True,  'ROC_{length}',     lambda d,l: {'close': d.Close, 'length': l}),
    (ta.psar,     False, None,               lambda d,l: {'high': d.High, 'low': d.Low}),
    (ta.nvi,      True,  'NVI_{length}',     lambda d,l: {'close': d.Close, 'volume': d.Volume, 'length': l}),
    (ta.cmf,      True,  'CMF_{length}',     lambda d,l: {'high': d.High, 'low': d.Low,   'close': d.Close, 'volume': d.Volume, 'length': l}),
    (ta.ppo,      True,  'PPO_{length}',     lambda d,l: {'close': d.Close, 'fast': int(l*1.3), 'slow': int(l*3), 'signal': l}),
    (ta.pvo,      True,  'PVO_{length}',     lambda d,l: {'volume': d.Volume, 'fast': int(l*1.3), 'slow': int(l*2.6), 'signal': l}),
    (ta.rsi,      True,  'RSI_{length}',     lambda d,l: {'close': d.Close, 'length': l}),
    (ta.stoch,    True,  None,               lambda d,l: {'high': d.High, 'low': d.Low, 'close': d.Close, 'k': l, 'd': 3, 'smooth_k': 3}),
    (ta.stochrsi, True,  None,               lambda d,l: {'close': d.Close, 'length': l, 'rsi_length': l, 'k': 3, 'd': 3}),
    (ta.trix,     True,  None,               lambda d,l: {'close': d.Close, 'length': int(l*2), 'signal': l}),
    (ta.uo,       True,  'UO_{length}',      lambda d,l: {'high': d.High, 'low': d.Low, 'close': d.Close, 'fast': l, 'medium': l*2, 'slow': l*3}),
    (ta.willr,    True,  'WillR_{length}',   lambda d,l: {'high': d.High, 'low': d.Low, 'close': d.Close, 'length': l}),
    (ta.psl,      True,  'PSI_{length}',     lambda d,l: {'close': d.Close, 'length': l}),
    (ta.adx,      True,  'ADX_{length}',     lambda d,l: {'high': d.High, 'low': d.Low, 'close': d.Close, 'length': l}),
    (ta.cci,      True,  'CCI_{length}',     lambda d,l: {'high': d.High, 'low': d.Low, 'close': d.Close, 'length': l}),
    (ta.macd,     True,  None,               lambda d,l: {'close': d.Close, 'fast': int(l*1.3), 'slow': int(l*3), 'signal': l}),
    (ta.massi,    True,  'MassIndex_{length}', lambda d,l: {'high': d.High, 'low': d.Low, 'fast': l, 'slow': int(l*2.5)}),
    (ta.ad,       False, 'ADLine',           lambda d,l: {'high': d.High, 'low': d.Low, 'close': d.Close, 'volume': d.Volume}),
    (ta.adosc,    True,  'CO_{length}',      lambda d,l: {'high': d.High, 'low': d.Low, 'close': d.Close, 'volume': d.Volume, 'fast': 3, 'slow': l*2}),
    (ta.eom,      True,  'EOM_{length}',     lambda d,l: {'high': d.High, 'low': d.Low, 'close': d.Close, 'volume': d.Volume, 'length': l}),
    (ta.obv,      False, 'OBV',              lambda d,l: {'close': d.Close, 'volume': d.Volume}),
    (ta.pvt,      False, 'PVT',              lambda d,l: {'close': d.Close, 'volume': d.Volume}),
    (ta.atr,      True,  'ATR_{length}',     lambda d,l: {'high': d.High, 'low': d.Low, 'close': d.Close, 'length': l}),
    (ta.bbands,   True,  None,               lambda d,l: {'close': d.Close, 'length': l}),
    (ta.donchian, False, None,               lambda d,l: {'high': d.High, 'low': d.Low}),
    (ta.kc,       True,  None,               lambda d,l: {'high': d.High, 'low': d.Low, 'close': d.Close, 'length': l}),
    (ta.sma,      True,  'AvgVol_{length}',  lambda d,l: {'close': d.Volume, 'length': l}),
]

# 3) 지표 일괄 적용
for func, per_len, name_fmt, kwargs_fn in indicator_cfg:
    if func is ta.adx:
        # DMP/DMN 컬럼 충돌 방지: ADX 시리즈만 추출
        for l in lengths:
            adx_ser = func(**kwargs_fn(df, l))[f'ADX_{l}']
            df = apply_indicator(df, adx_ser, prefix=name_fmt.format(length=l))
        continue

    if per_len:
        for l in lengths:
            res = func(**kwargs_fn(df, l))
            col = name_fmt.format(length=l) if name_fmt else None
            df = apply_indicator(df, res, prefix=col)
    else:
        res = func(**kwargs_fn(df, None))
        df = apply_indicator(df, res, prefix=name_fmt)

# 4) Volume Ratio
for l in lengths:
    df[f'VRatio_{l}'] = df['Volume'] / df[f'AvgVol_{l}']

# 5) Pivot Points
df['Pivot']    = (df.High.shift(1) + df.Low.shift(1) + df.Close.shift(1)) / 3
df['Pivot_R1'] = 2 * df.Pivot - df.Low.shift(1)
df['Pivot_S1'] = 2 * df.Pivot - df.High.shift(1)
df['Pivot_R2'] = df.Pivot + (df.High.shift(1) - df.Low.shift(1))
df['Pivot_S2'] = df.Pivot - (df.High.shift(1) - df.Low.shift(1))

# 6) Trend_value.csv, columns_only.csv 저장
df.to_csv('TA_Value.csv', index=False, encoding='utf-8-sig')
pd.Series(df.columns).to_csv('columns_only.csv', index=False,
                            header=False, encoding='utf-8')
print("지표 계산이 완료되었습니다.")

# --- 여기까지가 지표 계산 파트 ---

# 7) 세그먼트 분석을 위해 정렬 및 인덱스 리셋
df = df.sort_values(['Code', 'Date']).reset_index(drop=True)

# 8) ret_1~ret_5, ret_avg_1~ret_avg_5 계산
for n in range(1, 6):
    df[f'ret_{n}'] = df.groupby('Code')['Close'].shift(-n) / df['Close'] - 1
    cols = [f'ret_{i}' for i in range(1, n+1)]
    df[f'ret_avg_{n}'] = df[cols].mean(axis=1)

# 9) 분석 대상 컬럼 분리
base_cols    = ["Code","Company","Date","Open","High","Low","Close","Volume","Change","Stage"]
ret_cols     = [f"ret_{i}" for i in range(1,6)]
avg_cols     = [f"ret_avg_{i}" for i in range(1,6)]
exclude_cols = base_cols + ret_cols + avg_cols
ind_cols     = [c for c in df.columns if c not in exclude_cols]

# 10) Stage별, indicator별 히트율 계산
stage_counts = df['Stage'].value_counts().to_dict()
results = []

for stage in stage_counts:
    mask_stage = df['Stage'] == stage
    for col in ind_cols:
        ser = pd.to_numeric(df[col], errors='coerce').dropna()
        if ser.empty: 
            continue

        p10, p90 = np.nanpercentile(ser, [10, 90])
        if np.isnan(p10) or np.isnan(p90) or p10 >= p90:
            p10, p90 = ser.min(), ser.max()

        bins    = np.linspace(p10, p90, 51)
        sig_ind = df[col] > 0

        for i in range(50):
            lo, hi = bins[i], bins[i+1]
            if i < 49:
                mask_bin = (df[col] >= lo) & (df[col] < hi)
            else:
                mask_bin = (df[col] >= lo) & (df[col] <= hi)

            mask_bs   = mask_stage & mask_bin
            bin_count = mask_bs.sum()
            if bin_count == 0:
                continue

            for N in range(1, 6):
                sig_price = df[f'ret_avg_{N}'] > 0
                hits      = ((mask_bs & sig_ind) & sig_price).sum()
                hit_rate  = hits / bin_count

                results.append({
                    "Stage":     stage,
                    "indicator": col,
                    "N_days":    N,
                    "bin_index": i+1,
                    "bin_lo":    lo,
                    "bin_hi":    hi,
                    "bin_count": int(bin_count),
                    "hit_count": int(hits),
                    "hit_rate":  hit_rate
                })

# 11) DataFrame 변환 및 의미 있는 세그먼트 추출
res_df       = pd.DataFrame(results)
threshold    = 0.75
min_length   = 5
total_non_na = df[ind_cols].count().to_dict()
segments     = []

for (stage, ind, N), grp in res_df.groupby(['Stage','indicator','N_days']):
    grp = grp.sort_values('bin_index').reset_index(drop=True)
    hr  = grp['hit_rate'].values
    hr_ext = hr.copy()
    for i in range(1, len(hr)-1):
        if hr[i] < threshold and hr[i-1] >= threshold and hr[i+1] >= threshold:
            hr_ext[i] = threshold
    mask = hr_ext >= threshold

    start = None
    for i, flag in enumerate(mask):
        if flag and start is None:
            start = i
        elif not flag and start is not None:
            seg = grp.loc[start:i-1]
            length = seg.bin_index.iloc[-1] - seg.bin_index.iloc[0]
            if length >= min_length:
                seg_count       = seg.bin_count.sum()
                seg_hit_count   = seg.hit_count.sum()
                lo, hi          = seg.bin_lo.iloc[0], seg.bin_hi.iloc[-1]
                overall_pct     = seg_count / total_non_na[ind]
                mask_hits       = (
                    (df.Stage == stage) &
                    (df[ind] >= lo) & (df[ind] <= hi) &
                    (df[ind] > 0) &
                    (df[f'ret_avg_{N}'] > 0)
                )
                seg_hit_return  = df.loc[mask_hits, f'ret_avg_{N}'].mean()
                segments.append({
                    "Stage":             stage,
                    "indicator":         ind,
                    "N_days":            N,
                    "bin_start":         int(seg.bin_index.iloc[0]),
                    "bin_end":           int(seg.bin_index.iloc[-1]),
                    "seg_lo":            float(lo),
                    "seg_hi":            float(hi),
                    "seg_count":         int(seg_count),
                    "seg_hit_count":     int(seg_hit_count),
                    "seg_hit_rate":      float(seg.hit_rate.mean()),
                    "seg_hit_pct":       seg_hit_count / seg_count,
                    "seg_hit_return_avg": seg_hit_return,
                    "overall_pct":       overall_pct
                })
            start = None
    # 마지막 열린 세그먼트 처리
    if start is not None:
        seg = grp.loc[start:]
        length = seg.bin_index.iloc[-1] - seg.bin_index.iloc[0]
        if length >= min_length:
            seg_count       = seg.bin_count.sum()
            seg_hit_count   = seg.hit_count.sum()
            lo, hi          = seg.bin_lo.iloc[0], seg.bin_hi.iloc[-1]
            overall_pct     = seg_count / total_non_na[ind]
            mask_hits       = (
                (df.Stage == stage) &
                (df[ind] >= lo) & (df[ind] <= hi) &
                (df[ind] > 0) &
                (df[f'ret_avg_{N}'] > 0)
            )
            seg_hit_return  = df.loc[mask_hits, f'ret_avg_{N}'].mean()
            segments.append({
                "Stage":             stage,
                "indicator":         ind,
                "N_days":            N,
                "bin_start":         int(seg.bin_index.iloc[0]),
                "bin_end":           int(seg.bin_index.iloc[-1]),
                "seg_lo":            float(lo),
                "seg_hi":            float(hi),
                "seg_count":         int(seg_count),
                "seg_hit_count":     int(seg_hit_count),
                "seg_hit_rate":      float(seg.hit_rate.mean()),
                "seg_hit_pct":       seg_hit_count / seg_count,
                "seg_hit_return_avg": seg_hit_return,
                "overall_pct":       overall_pct
            })

# 12) indicator별 최소 5개 세그먼트 & overall_pct>=0.01 필터링
seg_df     = pd.DataFrame(segments)
valid_inds = seg_df.groupby('indicator').size().loc[lambda x: x>=5].index
final_df   = seg_df[seg_df.indicator.isin(valid_inds)]

# overall_pct 1% 미만 제거
final_df   = final_df[final_df['overall_pct'] >= 0.01]

# 13) 정렬 및 컬럼 순서 재배열
final_df = final_df.sort_values(['Stage','N_days','indicator'])\
                   .reset_index(drop=True)

cols_order = ['Stage','N_days','indicator'] + \
             [c for c in final_df.columns if c not in ['Stage','N_days','indicator']]
final_df = final_df[cols_order]

# 14) 출력 & 저장
print("최종 유의미 세그먼트 (overall_pct>=1%) 작성이 완료되었습니다.")

final_df.to_csv('TA_segmented.csv',
                index=False, encoding='utf-8-sig')
