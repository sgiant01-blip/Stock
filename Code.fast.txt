import pandas as pd
import numpy as np
import time
from tqdm import tqdm

RAW_PARQUET = 'TA_values.All.parquet'
OUT_PARQUET = 'TA_segmented_optimized.parquet'
OUT_CSV     = 'TA_segmented_optimized.csv'  # 필요 시

def compute_future_returns_vect(df, days=[1,2,3,4,5]):
    start = time.perf_counter()
    grp = df.groupby('Code')['Close']
    future = np.stack([grp.shift(-d).to_numpy() for d in days], axis=1)
    base   = df['Close'].to_numpy()[:, None]
    rets   = future / base - 1

    ret_cols     = [f'ret_{d}'     for d in days]
    ret_avg_cols = [f'ret_avg_{d}' for d in days]

    ret_df     = pd.DataFrame(rets, columns=ret_cols,     index=df.index)
    cum_mean   = np.cumsum(rets, axis=1) / (np.arange(len(days)) + 1)
    ret_avg_df = pd.DataFrame(cum_mean, columns=ret_avg_cols, index=df.index)
    df = pd.concat([df, ret_df, ret_avg_df], axis=1)

    print(f"[compute_returns] {(time.perf_counter()-start):.2f}s")
    return df

def segment_and_summarize_fast(df,
                               days=[1,2,3,4,5],
                               lower=0.1,
                               upper=0.9,
                               n_segments=50):
    start = time.perf_counter()
    # 제외할 컬럼 & ret 컬럼 정의
    base_drop = ['Code','Company','Stage','Date',
                 'Open','High','Low','Close','Volume','Change']
    ret_cols  = [f'ret_{i}'     for i in days] + \
                [f'ret_avg_{i}' for i in days]

    # 숫자형 컬럼 중 지표 후보만 선택
    numeric_cols   = df.select_dtypes(include='number').columns
    indicator_cols = [c for c in numeric_cols if c not in base_drop + ret_cols]

    total_tasks = len(indicator_cols) * len(days)
    pbar = tqdm(total=total_tasks,
                desc='세그먼트 처리 진행',
                unit='task',
                ncols=80)

    results = []
    for ind in indicator_cols:
        lo, hi = df[ind].quantile([lower, upper])
        sel = df.loc[
            df[ind].between(lo, hi),
            ['Stage', ind] + [f'ret_avg_{d}' for d in days]
        ].copy()

        # 샘플 부족 시 스킵 + bar 채우기
        if sel.shape[0] < n_segments:
            pbar.update(len(days))
            continue

        sel['segment']    = pd.qcut(
            sel[ind], q=n_segments,
            labels=False, duplicates='drop'
        )
        sel['segment_lo'] = sel.groupby('segment')[ind].transform('min')
        sel['segment_hi'] = sel.groupby('segment')[ind].transform('max')
        sel[f'{ind}_dir'] = sel[ind].diff() > 0

        for d in days:
            ret_col = f'ret_avg_{d}'
            grp = sel.dropna(subset=[ret_col]).groupby(
                ['Stage','segment','segment_lo','segment_hi']
            )
            agg = grp.agg(
                total_count=('segment','size'),
                pos_match  =(f'{ind}_dir','sum'),
                mean_return=(ret_col,'mean'),
                neg3_count =(ret_col, lambda x: (x <= -0.03).sum()),
                min_return =(ret_col,'min')
            ).reset_index()

            agg['pos_ratio']  = agg['pos_match']  / agg['total_count']
            agg['neg3_ratio'] = agg['neg3_count'] / agg['total_count']
            agg['indicator']  = ind
            agg['day']        = d

            results.append(agg)
            pbar.update(1)

    pbar.close()
    print(f"[segmentation] {(time.perf_counter()-start):.2f}s")
    return pd.concat(results, ignore_index=True)

def main():
    total_start = time.perf_counter()
    print("▶ Step 1/4: Load & preprocess")
    df = pd.read_parquet(RAW_PARQUET)
    df['Date']  = pd.to_datetime(df['Date'])
    df['Stage'] = df['Stage'].astype('category')
    print(f"   완료: {(time.perf_counter()-total_start):.2f}s\n")

    print("▶ Step 2/4: Compute future returns")
    df = compute_future_returns_vect(df)
    print()

    print("▶ Step 3/4: Segment & summarize")
    seg_summary = segment_and_summarize_fast(df)
    print("\n  ▶ Before filter:", seg_summary.shape)

    # total_count == 0 인 세그먼트 제거
    seg_summary = seg_summary[seg_summary['total_count'] > 0].copy()
    print("  ▶ After filter:", seg_summary.shape, "\n")

    print("▶ Step 4/4: Save results")
    ordered_cols = [
        'Stage','day','indicator','segment_lo','segment_hi',
        'total_count','pos_match','pos_ratio',
        'mean_return','neg3_count','neg3_ratio','min_return'
    ]
    seg_summary = seg_summary[ordered_cols] \
                  .sort_values(['Stage','day','indicator']) \
                  .reset_index(drop=True)

    # 1) Parquet 포맷으로 저장 (추천)
    seg_summary.to_parquet(OUT_PARQUET,
                           index=False,
                           compression='snappy')
    print("   Parquet 저장 완료")

    seg_summary.to_excel(
    'TA_segmented_optimized.xlsx',
    index=False,
    engine='openpyxl')

    print(f"\n[전체] 총 실행 시간: {(time.perf_counter()-total_start):.2f}s")

if __name__ == '__main__':
    main()