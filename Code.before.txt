import pandas as pd
import numpy as np

RAW_PARQUET = 'TA_values.All.parquet'
out_csv     = 'TA_segmented.csv'

def compute_future_returns(df, days=[1,2,3,4,5]):
    for d in days:
        df[f"ret_{d}"] = df.groupby("Code")["Close"].shift(-d).div(df["Close"]).sub(1)
    for d in days:
        df[f"ret_avg_{d}"] = df[[f"ret_{i}" for i in range(1, d+1)]].mean(axis=1)
    return df

def segment_and_summarize(df, days=[1,2,3,4,5], lower_pct=0.10, upper_pct=0.90, n_segments=50):
    base_cols = ["Code", "Company", "Date", "Open", "High", "Low", "Close", "Volume", "Change", "Stage"]
    ret_cols  = [f"ret_{i}" for i in range(1,6)] + [f"ret_avg_{i}" for i in range(1,6)]
    indicator_cols = [c for c in df.columns if c not in base_cols + ret_cols]

    results = []

    for ind in indicator_cols:
        df_ind = df.copy()
        df_ind["rank_pct"] = df_ind[ind].rank(method="first", pct=True)
        mask = df_ind["rank_pct"].between(lower_pct, upper_pct)
        df_mid = df_ind[mask].copy()

        try:
            df_mid["segment"] = pd.qcut(df_mid[ind], q=n_segments, labels=False, duplicates="drop")
        except ValueError:
            continue  # 지표 값이 너무 적으면 건너뜀

        # segment 범위 계산
        seg_bounds = df_mid.groupby("segment")[ind].agg(["min", "max"]).rename(columns={"min":"segment_lo", "max":"segment_hi"})

        df_mid = df_mid.merge(seg_bounds, on="segment", how="left")
        df_mid[f"{ind}_dir"] = df_mid[ind].diff() > 0

        for d in days:
            ret_col = f"ret_avg_{d}"
            grp = df_mid.dropna(subset=["segment", ret_col]).groupby(["Stage", "segment", "segment_lo", "segment_hi"])

            agg = grp.agg(
                total_count = ("segment", "size"),
                pos_match   = (f"{ind}_dir", "sum"),
                mean_return = (ret_col, "mean"),
                neg3_count  = (ret_col, lambda x: (x <= -0.03).sum()),
                min_return  = (ret_col, "min")
            ).reset_index()

            agg["pos_ratio"]  = agg["pos_match"] / agg["total_count"]
            agg["neg3_ratio"] = agg["neg3_count"] / agg["total_count"]
            agg["indicator"]  = ind
            agg["day"]        = d

            results.append(agg)

    return pd.concat(results, ignore_index=True)
# ──────────────────────────────────────────────────────────────────────

# 파이프라인 실행

df = pd.read_parquet(RAW_PARQUET)
df["Date"] = pd.to_datetime(df["Date"])
df.reset_index(drop=True, inplace=True)

df = compute_future_returns(df, days=[1,2,3,4,5])
seg_summary = segment_and_summarize(df)

ordered_cols = [
    "Stage", "day", "indicator", "segment_lo", "segment_hi",
    "total_count", "pos_match", "pos_ratio",
    "mean_return", "neg3_count", "neg3_ratio", "min_return"
]
seg_summary = seg_summary[ordered_cols].sort_values(["Stage", "day", "indicator"]).reset_index(drop=True)

seg_summary.to_csv(out_csv, index=False, encoding='utf-8-sig')


